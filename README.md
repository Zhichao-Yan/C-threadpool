# C-threadpool
[参考资料](https://www.jianshu.com/p/95057accd231)

线程池技术：一种常见的多线程并发编程技术，它将多个线程组织在一起，以便能够更有效地管理和控制它们的执行
* 降低资源消耗：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。
* 提高响应速度：任务到达时，无需等待线程创建即可立即执行
* 提高线程的可管理性：使用线程池可以进行统一的分配、调优和监控

“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。除了线程池还有
* 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。
* 连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。
* 实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。


如果不用线程池，那么就必须对每一个任务创建一个线程进行处理，涉及大量线程的创建和销毁，导致：
1. 消耗大量的时间，导致应用性能上的缺失
2. 非常消耗CPU和内存
3. 内存垃圾回收机制，造成内存抖动
解决的办法：重用已有的线程，从而减少线程的创建和销毁。----线程池

线程池参数设置：
1. 核心线程数量：不管它们创建以后是不是空闲的。线程池需要保持数量的线程
2. 最大线程数量：线程池中最多允许创建maximumPoolSize个线程
3. 保持活动时间：当线程池中的线程数量超过了核心线程数目时，它表示多余的空闲线程的存活时间
    * 太小：空闲线程很短时间死掉，面对新任务需要创建线程，
    * 太长：大量线程消耗系统资源
4. 任务队列
5. 线程工厂
6. 拒绝策略：活跃线程数达到最大线程数时，最大线程数的线程都在工作时，线程池接收到新的任务就会执行拒绝策略
    * DiscardOldestPolicy
    丢弃阻塞队列 workQueue 中最老的一个任务，将当前这个任务继续提交给线程池，加入队列中
    * CallerRunsPolicy
    调用线程池的主线程处理
    * DiscardPolicy
    直接丢弃任务，不做任何处理，没有异常
    * AbortPolicy
    丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息，必须处理抛出的异常


线程池设置难点：
1. 通用的线程池考虑的参数类型太多，需要考虑业务场景和需求如计算密集型和IO密集型的线程池参数设置肯定不同
2. 线程池运行情况黑盒，无法准确的进行调优
3. 线程池涉及参数太多

线程池参数设置方案
1. 线程数 = CPU核数 * CPU期望利用率 * (1 + 等待时间/计算时间)
缺点：计算时间和等待时间难以确定，偏理论化
2. 核心线程数 = 2 * CPU核数  最大线程数 = 25 * CPU核数
3. 核心线程数 = tps * time 最大线程数 = tps*time*（1.7 ～2）

线程池的方法设置不固定，总的方法是：评估+压测+监控+动态调整
* 评估：可以根据请求流量估算线程池参数
corePoolSize = 日常的QPS * RT(ms) / 1000，maxPoolSize = 峰值QPS * RT(ms) / 1000
* 告警：当线程池参数超过某个阀值，进行告警
    * 活跃线程数 > 最大线程数 * 0.8。
    * 当前等待队列长度 > 设置值 * 0.8。
* 监控：监控线程池运行状况
    * 线程池活跃度：activeCount / maximumPoolSize--》用于描述线程池负载情况
    * 队列饱和度：queueSize / queueCapacity --》用户描述工作队列负载情况
    * 任务阻塞时间：executeStartTime-inQueueTime-》用户描述任务排队情况

* 线程池运行流程
1. 首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。
2. 如果workerCount < corePoolSize，无论是否其中有空闲的线程,创建并启动一个线程来执行新提交的任务。
2. 如果池中的workerCount大于corePoolSize并且小于maximumPoolSize,而又有空闲线程，就给新任务使用空闲线程
3. 如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。
4. 如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。
5. 如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。

-------------------------

> Java推荐使用Executors的工厂方法来创建线程池.Executors类是官方提供的一个工厂类，它里面封装好了众多功能不一样的线程池，从而使得我们创建线程池非常的简便
主要提供了如下五种功能不一样的线程池：
1. `newFixedThreadPool`线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程,最大并发数固定
e.g. 假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按FIFO处理任务
2. `newCachedThreadPool`实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的
e.g. 假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为60s。
3. `newSingleThreadExecutor`方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务
e.g. 每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。
4. `newScheduledThreadPool`返回一个可以控制线程池内线程定时或周期性执行某任务的线程池，数量可以设置
5. `newSingleThreadScheduledExecutor`可以控制线程池内线程定时或周期性执行某任务的线程池,不过该线程池大小为1




---------------
面试问题
1. 为什么线程池中要使用堵塞队列？
> 线程从阻塞队列取任务时，如果阻塞队列不为空则立即返回，如果为空，则线程会被阻塞，一直等待，直到队列中有新的任务，这样就充分的利用了阻塞队列堵塞和通知线程的功能。当核心线程处理不过来，可以通过堵塞队列进行任务堆积
2. 非核心线程能成为核心线程吗？
> 核心线程和非核心线程是理解上的区分，线程池内部并不区分核心线程和非核心线程的，会根据池的工作线程数 countWorker和 corePoolSize 进行调整:
> * 当 countWorker <= corePoolSize，则 countWorker这些线程被理解成核心线程；
> * 当 corePoolSize < countWorker < maximumPoolSize，则 countWorker - corePoolSize 这部分线程被理解成非核心线程；
3. 线程池中的线程在什么时候创建
> 可以在任务到达时创建，也可以在线程池初始化时创建
