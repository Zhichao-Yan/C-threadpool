# C-threadpool
[参考资料](https://www.jianshu.com/p/95057accd231)

线程池技术：一种常见的多线程并发编程技术，它将多个线程组织在一起，以便能够更有效地管理和控制它们的执行
* 降低资源消耗：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。
* 提高响应速度：任务到达时，无需等待线程创建即可立即执行
* 提高线程的可管理性：使用线程池可以进行统一的分配、调优和监控

“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。除了线程池还有
* 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。
* 连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。
* 实例池(Object Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。

如果不用线程池，那么就必须对每一个任务创建一个线程进行处理，涉及大量线程的创建和销毁，导致：
1. 消耗大量的时间
2. 非常消耗CPU和内存
3. 不断重复创建消耗，容易使内存回收机制造成内存抖动

线程池设置难点：
1. 通用的线程池考虑的参数类型太多，需要考虑业务场景和需求如计算密集型和IO密集型的线程池参数设置肯定不同
2. 线程池运行情况黑盒，无法准确的进行调优
3. 线程池涉及参数太多

线程池参数设置方案
1. 线程数 = CPU核数 * CPU期望利用率 * (1 + 等待时间/计算时间)
缺点：计算时间和等待时间难以确定，偏理论化
2. 核心线程数 = 2 * CPU核数  最大线程数 = 25 * CPU核数
3. 核心线程数 = tps * time  最大线程数 = tps*time*（1.7 ～2）

线程池的方法设置不固定，总的方法是：评估+压测+监控+动态调整
* 评估：可以根据平时的请求流量估算线程池的初始参数
`corePoolSize = 日常的QPS * RT(ms) / 1000，maxPoolSize = 峰值QPS * RT(ms) / 1000`
* 告警：当线程池参数超过某个阀值，进行告警
    * 活跃线程数 > 最大线程数 * 0.8。
    * 当前等待队列长度 > 设置值 * 0.8。
* 监控：监控线程池运行状况
    * 线程池活跃度：activeCount / maximumPoolSize--》用于描述线程池负载情况
    * 队列饱和度：queueSize / queueCapacity --》用户描述工作队列负载情况
    * 任务阻塞时间：executeStartTime-inQueueTime-》用户描述任务排队情况
* 动态调整：动态调整策略改变线程数量


---------------
面试问题
1. 为什么线程池中要使用堵塞队列？
> 线程从阻塞队列取任务时，如果阻塞队列不为空则立即返回，如果为空，则线程会被阻塞，一直等待，直到队列中有新的任务，这样就充分的利用了阻塞队列堵塞和通知线程的功能。当核心线程处理不过来，可以通过堵塞队列进行任务堆积
2. 非核心线程能成为核心线程吗？
> 核心线程和非核心线程是理解上的区分，线程池内部并不区分核心线程和非核心线程的，会根据池的工作线程数 countWorker和 corePoolSize 进行调整:
> * 当 countWorker <= corePoolSize，则 countWorker这些线程被理解成核心线程；
> * 当 corePoolSize < countWorker < maximumPoolSize，则 countWorker - corePoolSize 这部分线程被理解成非核心线程；
3. 线程池中的线程在什么时候创建
> 可以在任务到达时创建，也可以在线程池初始化时创建
